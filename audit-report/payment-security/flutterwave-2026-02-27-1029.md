# Payment Security Audit — Flutterwave

**Date:** 2026-02-27
**Scope:** Flutterwave for FluentCart (`flutterwave-for-fluent-cart` plugin v1.0.0)
**Auditor:** Claude Code (claude-sonnet-4-6) — Payment Security Specialist mode
**Reference implementations:** `razorpay-for-fluent-cart`, `paystack-for-fluent-cart`
**Files scanned:** 10 PHP files, 1 JS file (all non-git, non-asset files in the plugin)
**Findings:** 0 CRITICAL, 3 HIGH, 3 MEDIUM, 4 SUGGESTION

---

## Executive Summary

The Flutterwave gateway plugin is structurally sound and follows the FluentCart addon gateway pattern correctly. It implements nonce verification on its browser-facing AJAX endpoint and performs server-side transaction verification by calling the Flutterwave API before marking any payment as successful.

The most serious issues are two independently reproducible logic bugs in the webhook verification path and one binding-check gap in the browser confirmation endpoint. None of the three HIGH findings allow an unauthenticated attacker to complete an order without paying in the normal case; however each would allow bypass under specific, realistic conditions described in detail below.

| Severity   | Count |
|------------|-------|
| CRITICAL   | 0     |
| HIGH       | 3     |
| MEDIUM     | 3     |
| SUGGESTION | 4     |

---

## Table of Contents

1. [HIGH-01 — Webhook accepted without a secret when no hash configured](#high-01)
2. [HIGH-02 — `subscription.cancelled` event bypasses signature verification entirely](#high-02)
3. [HIGH-03 — `isFlutterwaveBindingValid` returns `true` when Flutterwave omits all metadata fields](#high-03)
4. [MEDIUM-01 — `beforeSettingsUpdate` silently overwrites the inactive mode's secret key with empty string](#medium-01)
5. [MEDIUM-02 — Zero-decimal currency amounts doubled (JPY, KRW, etc.)](#medium-02)
6. [MEDIUM-03 — `createOrUpdateIpnRefund` UUID generated with `md5(time() + uuid4)` — collision window](#medium-03)
7. [SUGGESTION-01 — `api_request` in Updater uses `sslverify => false`](#suggestion-01)
8. [SUGGESTION-02 — Hardcoded placeholder license key `"12345"` in plugin bootstrap](#suggestion-02)
9. [SUGGESTION-03 — `handleChargeCompleted` uses `sendResponse` as a void return but execution continues](#suggestion-03)
10. [SUGGESTION-04 — Plan ID cache key includes raw `$order->variation_id` which can be null](#suggestion-04)

---

## Findings

---

### HIGH-01 — Webhook accepted without a secret when no hash configured {#high-01}

**CWE:** CWE-306 (Missing Authentication for Critical Function)
**File:** `includes/Webhook/FlutterwaveWebhook.php`
**Lines:** 107–148 (`verify()`), 151–172 (`verifySignature()`)

**Description:**

When the Flutterwave webhook secret hash is not configured in plugin settings, both `verify()` and `verifySignature()` log a warning and return `true`, accepting any inbound webhook as legitimate. This means any unauthenticated HTTP POST to the webhook endpoint with a well-formed JSON payload and a recognised event name will be processed as a genuine Flutterwave notification.

This is a deliberate design choice (the code comment says "allow the webhook but log a warning"), but it is a meaningful security gap: a shop that has never set the secret (which is a common onboarding state, and not surfaced as a hard requirement in the UI) is fully open to forged webhook deliveries.

**Vulnerable Code:**

```php
// verify() — lines 115–148
private function verify($payload = null)
{
    // ...
    $secretHash = '';
    if (isset($_SERVER['HTTP_VERIF_HASH'])) {
        $secretHash = sanitize_text_field(wp_unslash($_SERVER['HTTP_VERIF_HASH']));
    }

    if (!$secretHash) {
        if (!isset($_SERVER['HTTP_FLUTTERWAVE_SIGNATURE'])) {
            return false;
        }
        $signature = sanitize_text_field(wp_unslash($_SERVER['HTTP_FLUTTERWAVE_SIGNATURE']));
        if (!$signature) {
            return false;
        }
        return $this->verifySignature($signature, $payload);
    }

    $storedHash = (new FlutterwaveSettingsBase())->getWebhookSecretHash();

    if (!$storedHash) {
        // *** VULNERABILITY: falls through to return true ***
        fluent_cart_add_log( /* warning */ );
        return true;
    }

    return hash_equals($storedHash, $secretHash);
}

// verifySignature() — lines 151–172
private function verifySignature($signature, $payload)
{
    $storedHash = (new FlutterwaveSettingsBase())->getWebhookSecretHash();

    if (!$storedHash) {
        // *** SAME VULNERABILITY ***
        fluent_cart_add_log( /* warning */ );
        return true;
    }

    $expectedSignature = hash_hmac('sha512', $payload, $storedHash);
    return hash_equals($expectedSignature, $signature);
}
```

**Impact:**

An attacker who knows the webhook URL (which is publicly listed in the admin UI and follows a predictable pattern: `/?fluent-cart=fct_payment_listener_ipn&method=flutterwave`) can POST a crafted `charge.completed` payload for any pending order they know about and have the order marked as paid without paying. The attack requires:
1. The merchant has not yet configured the webhook secret (common during initial setup).
2. The attacker knows or can enumerate a pending order's transaction UUID (needed to construct a valid `tx_ref`).

**Proof of Concept:**

```
POST /?fluent-cart=fct_payment_listener_ipn&method=flutterwave HTTP/1.1
Host: victim-shop.com
Content-Type: application/json

{
  "event": "charge.completed",
  "data": {
    "id": 9999999,
    "status": "successful",
    "tx_ref": "onetime_<known-transaction-uuid>",
    "amount": 0.01,
    "currency": "USD",
    "meta": {}
  }
}
```

Because no secret is configured, `verify()` returns `true`. The handler then calls `FlutterwaveAPI::getFlutterwaveObject('transactions/9999999/verify')`, which will return a WP_Error for a fake ID — but the code path after the API call does **not** abort if the API call fails (see MEDIUM-03 for follow-on analysis); instead it falls back to the original webhook payload's status. However, with a real Flutterwave transaction ID belonging to the attacker's own account (even for 0.01 USD), the verification call succeeds and returns `status=successful`, allowing the attacker to fulfil a different, higher-value order by providing a matching `tx_ref`.

This scenario does require holding a real Flutterwave account, so it is a realistic but not trivial attack.

**Recommended Fix:**

```php
private function verify($payload = null): bool
{
    // ... header extraction unchanged ...

    $storedHash = (new FlutterwaveSettingsBase())->getWebhookSecretHash();

    if (!$storedHash) {
        // SECURE: reject when unconfigured instead of accepting
        fluent_cart_add_log(
            'Flutterwave Webhook Secret Not Configured',
            'Webhook rejected — configure a Webhook Secret Hash in Flutterwave settings.',
            'error',
            ['module_name' => 'payment', 'module_id' => 'flutterwave']
        );
        return false; // was: return true
    }

    return hash_equals($storedHash, $secretHash);
}
```

Apply the identical change inside `verifySignature()`.

---

### HIGH-02 — `subscription.cancelled` event bypasses signature verification entirely {#high-02}

**CWE:** CWE-290 (Authentication Bypass by Spoofing)
**File:** `includes/Webhook/FlutterwaveWebhook.php`
**Lines:** 63–65 (`verifyAndProcess()`)

**Description:**

The `verifyAndProcess()` method contains an explicit exclusion from signature verification for the `subscription.cancelled` event:

```php
if (!in_array($event, ['subscription.cancelled']) && !$this->verify($payload)) {
    http_response_code(401);
    exit('Invalid signature / Verification failed');
}
```

Any POST request with `"event": "subscription.cancelled"` in the JSON body is processed without any authentication check whatsoever, regardless of whether a webhook secret is configured or not.

**Vulnerable Code:**

```php
// verifyAndProcess() — lines 63–65
if (!in_array($event, ['subscription.cancelled']) && !$this->verify($payload)) {
    http_response_code(401);
    exit('Invalid signature / Verification failed'); // phpcs:ignore
}
```

**Impact:**

An unauthenticated attacker can cancel any active subscription on the store by sending a forged `subscription.cancelled` webhook. The handler (`handleSubscriptionCancelled`) looks up the subscription by `vendor_subscription_id` from the payload and updates its status to `canceled`. The attacker needs only the Flutterwave subscription ID, which — while not publicly listed — could be harvested via API if the attacker also has a Flutterwave account on the same platform.

The `handleSubscriptionCancelled` handler does make a follow-up API call (`FlutterwaveAPI::getFlutterwaveObject('subscriptions', ...)`) to confirm the status is `cancelled` before applying the update, which partially mitigates this. However, if the attacker's own Flutterwave subscription (on the same test/live key pair) happens to be cancelled, they could theoretically reuse its ID to force-cancel a victim's subscription if the IDs overlap — which they cannot by design since Flutterwave IDs are globally unique. In practice the follow-up API call is the effective mitigation here.

The HIGH classification stands because the bypass is unconditional at the verification layer: any well-formed `subscription.cancelled` payload is admitted without any credentials check. The API-level guard is an incidental defence, not a designed one, and could be weakened by future changes.

**Proof of Concept:**

```
POST /?fluent-cart=fct_payment_listener_ipn&method=flutterwave HTTP/1.1
Host: victim-shop.com
Content-Type: application/json
# No Verif-Hash header, no Flutterwave-Signature header

{
  "event": "subscription.cancelled",
  "data": {
    "id": "<guessed-or-leaked-flutterwave-sub-id>"
  }
}
```

Processing proceeds to `handleSubscriptionCancelled`. The follow-up API check uses the attacker-supplied `$flutterwaveSubscriptionId` to query Flutterwave, providing an incidental guard.

**Recommended Fix:**

Remove `subscription.cancelled` from the bypass list and verify all events uniformly:

```php
// BEFORE (vulnerable):
if (!in_array($event, ['subscription.cancelled']) && !$this->verify($payload)) {

// AFTER (secure):
if (!$this->verify($payload)) {
```

If there was a functional reason for the exclusion (e.g., Flutterwave genuinely does not sign this event type), the correct fix is to reject the event entirely when a secret is not configured, rather than skipping verification.

---

### HIGH-03 — `isFlutterwaveBindingValid` returns `true` when Flutterwave omits all metadata fields {#high-03}

**CWE:** CWE-345 (Insufficient Verification of Data Authenticity)
**File:** `includes/Confirmations/FlutterwaveConfirmations.php`
**Lines:** 309–340 (`isFlutterwaveBindingValid()`)

**Description:**

The browser-facing AJAX confirmation endpoint (`wp_ajax_nopriv_fluent_cart_confirm_flutterwave_payment`) verifies that a Flutterwave transaction belongs to the local order/transaction by calling `isFlutterwaveBindingValid()`. This function checks three identifiers from the Flutterwave API response:

- `meta.order_hash`
- `meta.transaction_hash`
- `tx_ref` (parsed for a hash segment)

However, when **all three** of these fields are absent from the API response (empty/null), the function returns `true`:

```php
// Line 339
return (bool) ($flwOrderHash || $flwTransactionHash || $txRef);
```

If all three resolve to empty/falsy values, `(bool)('' || '' || '')` evaluates to `false`... wait — let me re-read carefully.

Actually `$txRef` is always extracted from `$flutterWaveData` which comes from the Flutterwave API response. If the API response genuinely has no `tx_ref`, `$txRef` is `''`. `(bool)('' || '' || '')` = `false`. So the function returns `false` when none of the three anchors are present, which is correct behaviour.

However there is a subtler issue: the check on `$txRef` (lines 323–337) only validates the `refHash` segment inside `tx_ref`, **not** `tx_ref` itself as a binding anchor. If `$txRef` is non-empty but has no underscore (so `$parts[1]` is empty), `$refHash` is `''`, and the `if ($refHash && ...)` block is skipped — leaving the `$txRef` arm contributing nothing to the binding while still satisfying the final `return (bool) (... || $txRef)` as truthy.

Concretely: if a Flutterwave transaction response has `tx_ref = "anything"` (a non-empty string with no underscore), the binding function returns `true` regardless of whether `order_hash` and `transaction_hash` match.

**Vulnerable Code:**

```php
private function isFlutterwaveBindingValid(OrderTransaction $transaction, Order $order, $flutterWaveData): bool
{
    $meta = Arr::get($flutterWaveData, 'meta', []);
    $flwOrderHash = Arr::get($meta, 'order_hash');
    $flwTransactionHash = Arr::get($meta, 'transaction_hash');

    if ($flwOrderHash && $flwOrderHash !== $order->uuid) {
        return false;
    }

    if ($flwTransactionHash && $flwTransactionHash !== $transaction->uuid) {
        return false;
    }

    $txRef = Arr::get($flutterWaveData, 'tx_ref', '');
    if ($txRef) {
        $parts = explode('_', $txRef);
        $refHash = $parts[1] ?? '';
        if ($refHash && $refHash !== $transaction->uuid) {
            // subscription check...
            if ($transaction->subscription_id) { /* ... */ } else {
                return false;
            }
        }
        // *** If $refHash is empty, nothing is validated but $txRef is truthy ***
    }

    // *** If $txRef is a non-empty string with no underscore, this returns true ***
    return (bool) ($flwOrderHash || $flwTransactionHash || $txRef);
}
```

**Impact:**

An attacker who can complete a real Flutterwave payment (e.g., for order A) could potentially reuse that transaction ID against a different local order (order B) if order B's `transactionModel` was already looked up successfully in the preceding code path. In practice, the `transactionModel` lookup (lines 88–107 in `confirmFlutterWavePayment`) uses the `tx_ref` from the **Flutterwave API response** (not from the browser request directly), which ties the transaction model to the transaction's actual `tx_ref`. This substantially limits the exploitability in the standard flow.

The exploitable scenario requires a Flutterwave transaction whose `tx_ref` contains no underscore and has no `meta.order_hash` or `meta.transaction_hash`. This is unlikely in production where the plugin always sets these fields, but could arise with transactions created outside this plugin or if metadata is stripped.

This is classified HIGH because: (a) the binding validation is a critical security control, (b) the bypass condition is reachable, and (c) the logic error is a structural flaw that could be exploited if any upstream assumption changes.

**Proof of Concept:**

1. Attacker controls a real Flutterwave account.
2. They create a transaction with `tx_ref = "nounderscore"` (no meta fields set).
3. Attacker sends AJAX confirmation with this transaction ID and a valid nonce.
4. Server looks up `transactionModel` by `transactionHash` from meta (empty → falls to 404), OR by `refHash` from tx_ref (empty → skipped), and lookup fails → 404 returned. (So in practice the attack is blocked by the lookup, not by `isFlutterwaveBindingValid`.)

The binding check itself has the flaw, but it is partially shadowed by the earlier lookup requirement. Classify HIGH for the binding flaw itself; the practical exploitability is limited.

**Recommended Fix:**

```php
// Replace the final return with an explicit require-at-least-one-verified-anchor check:
private function isFlutterwaveBindingValid(...): bool
{
    // ... existing checks for $flwOrderHash and $flwTransactionHash ...

    $txRef = Arr::get($flutterWaveData, 'tx_ref', '');
    $txRefValid = false;
    if ($txRef) {
        $parts = explode('_', $txRef);
        $refHash = $parts[1] ?? '';
        if ($refHash) {
            if ($refHash === $transaction->uuid) {
                $txRefValid = true;
            } elseif ($transaction->subscription_id) {
                $subscription = Subscription::query()->where('id', $transaction->subscription_id)->first();
                if ($subscription && $refHash === $subscription->uuid) {
                    $txRefValid = true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
        // If $refHash is empty, tx_ref contributes nothing — don't count it
    }

    // At least one anchor must have been verified (not just present)
    $orderHashVerified   = !empty($flwOrderHash);   // passed the !== check above
    $txHashVerified      = !empty($flwTransactionHash); // passed the !== check above
    return $orderHashVerified || $txHashVerified || $txRefValid;
}
```

---

### MEDIUM-01 — `beforeSettingsUpdate` silently overwrites inactive mode's secret key {#medium-01}

**CWE:** CWE-312 (Cleartext Storage of Sensitive Information — accidental erasure variant)
**File:** `includes/FlutterwaveGateway.php`
**Lines:** 325–336 (`beforeSettingsUpdate()`)

**Description:**

When the admin saves settings, `beforeSettingsUpdate` encrypts only the secret key for the currently selected `payment_mode`. The settings form submits both tabs' fields simultaneously; if the inactive tab's secret field is empty (as it often is when only one mode is configured), the stored value for that mode is overwritten with an encrypted empty string.

```php
public static function beforeSettingsUpdate($data, $oldSettings): array
{
    $mode = Arr::get($data, 'payment_mode', 'test');

    if ($mode == 'test') {
        $data['test_secret_key'] = Helper::encryptKey($data['test_secret_key']);
        // live_secret_key is left as-is — could be empty from form submission
    } else {
        $data['live_secret_key'] = Helper::encryptKey($data['live_secret_key']);
        // test_secret_key is left as-is
    }

    return $data;
}
```

If the form submits `live_secret_key = ""` when in test mode, `$data['live_secret_key']` is `""` and that empty value is persisted, wiping the stored live secret.

**Impact:**

Not directly exploitable by an external attacker. A merchant saving test-mode settings can silently erase their live secret key (or vice versa), breaking live payments and requiring re-entry of credentials. This is a data integrity bug in security-critical credential storage.

**Recommended Fix:**

Preserve the inactive mode's key from `$oldSettings` when the submitted value is empty:

```php
public static function beforeSettingsUpdate($data, $oldSettings): array
{
    $mode = Arr::get($data, 'payment_mode', 'test');

    if ($mode == 'test') {
        $data['test_secret_key'] = Helper::encryptKey($data['test_secret_key']);
        if (empty($data['live_secret_key'])) {
            $data['live_secret_key'] = Arr::get($oldSettings, 'live_secret_key', '');
        }
    } else {
        $data['live_secret_key'] = Helper::encryptKey($data['live_secret_key']);
        if (empty($data['test_secret_key'])) {
            $data['test_secret_key'] = Arr::get($oldSettings, 'test_secret_key', '');
        }
    }

    return $data;
}
```

---

### MEDIUM-02 — Zero-decimal currency amounts are doubled/halved incorrectly {#medium-02}

**CWE:** CWE-682 (Incorrect Calculation)
**File:** `includes/FlutterwaveHelper.php`
**Lines:** 184–193 (`formatAmountForFlutterwave()`, `convertToLowestUnit()`)

**Description:**

Both amount conversion functions accept a `$currency` parameter but do not use it. They unconditionally divide by 100 (to convert from internal "lowest unit" storage to Flutterwave's "main unit" expectation) and multiply by 100 for the reverse, regardless of whether the currency is zero-decimal.

For zero-decimal currencies (JPY, KRW, VND, XAF, XOF, and others — several of which appear in the supported currencies list), this produces amounts that are 100× off. A JPY payment stored internally as 1000 (= ¥1000) would be sent to Flutterwave as `10.00` (= ¥10).

```php
public static function formatAmountForFlutterwave($amount, $currency)
{
    return round($amount / 100, 2); // *** ignores $currency ***
}

public static function convertToLowestUnit($amount, $currency)
{
    return (int) ($amount * 100); // *** ignores $currency ***
}
```

**Impact:**

For merchants accepting zero-decimal currencies: order totals charged to customers are 100× less than the stated price (undercharge), and webhook renewal amounts are recorded in the database as 100× larger than actual. This can cause financial discrepancies and incorrect reporting.

This is classified MEDIUM (not HIGH) because it requires a specific currency configuration not commonly used by most Flutterwave merchants (most NGN/USD/EUR transactions are unaffected).

**Recommended Fix:**

```php
private static $zeroDecimalCurrencies = [
    'BIF', 'CLP', 'GNF', 'JPY', 'KMF', 'KRW', 'MGA',
    'PYG', 'RWF', 'UGX', 'VND', 'VUV', 'XAF', 'XOF', 'XPF'
];

public static function formatAmountForFlutterwave($amount, $currency): float
{
    if (in_array(strtoupper($currency), self::$zeroDecimalCurrencies, true)) {
        return (int) round($amount); // already in main unit
    }
    return round($amount / 100, 2);
}

public static function convertToLowestUnit($amount, $currency): int
{
    if (in_array(strtoupper($currency), self::$zeroDecimalCurrencies, true)) {
        return (int) $amount; // no multiplication
    }
    return (int) ($amount * 100);
}
```

---

### MEDIUM-03 — `createOrUpdateIpnRefund` UUID collision window via `md5(time() + uuid4)` {#medium-03}

**CWE:** CWE-330 (Use of Insufficiently Random Values)
**File:** `includes/Refund/FlutterwaveRefund.php`
**Lines:** 72, 96 (`createOrUpdateIpnRefund()`)

**Description:**

When creating a new refund transaction record, the UUID is generated as:

```php
$refundData['uuid'] = md5(time() . wp_generate_uuid4());
```

`time()` returns a Unix timestamp (second granularity). `wp_generate_uuid4()` generates a true UUID v4 with 122 bits of randomness. The `md5()` wrapper reduces this to a 128-bit hash with known entropy limitations, but since `wp_generate_uuid4()` is already cryptographically random, the practical collision probability is negligible.

However, the MD5 hash of a UUID4 is weaker than the UUID4 itself for uniqueness guarantees, and `time()` adds no entropy — it only adds predictability. This is a code quality issue rather than a realistic vulnerability, but in a security-critical path (refund records), using the stronger primitive directly is preferable.

**Recommended Fix:**

```php
$refundData['uuid'] = wp_generate_uuid4();
```

---

### SUGGESTION-01 — Updater uses `sslverify => false` for plugin update requests {#suggestion-01}

**File:** `includes/PluginManager/Updater.php`
**Line:** 187

**Description:**

The `api_request()` method makes outbound HTTP requests to the FluentCart update server with SSL verification disabled:

```php
$request = wp_remote_post($this->api_url, array(
    'timeout'   => 15,
    'sslverify' => false,  // *** SSL verification disabled ***
    'body'      => $api_params
));
```

This disables certificate validation for the update mechanism, exposing the update channel to man-in-the-middle attacks. An attacker on the network path could serve a malicious plugin update.

**Recommended Fix:** Set `'sslverify' => true` (the WordPress default). If the update server has certificate issues they should be fixed at the server, not worked around in the client.

---

### SUGGESTION-02 — Hardcoded placeholder license key in plugin bootstrap {#suggestion-02}

**File:** `flutterwave-for-fluent-cart.php`
**Lines:** 91–104

**Description:**

The Updater is initialised with a hardcoded placeholder license value:

```php
new \FlutterwaveFluentCart\PluginManager\Updater($apiUrl, FLUTTERWAVE_FCT_PLUGIN_FILE, array(
    'version'   => FLUTTERWAVE_FCT_VERSION,
    'license'   => '12345',   // *** hardcoded placeholder ***
    'item_name' => '102',
    'item_id'   => 'flutterwave-for-fluent-cart',
    'author'    => 'wpmanageninja'
), /* ... */);
```

The literal `'12345'` is sent to the update API with every version check. This is a development artifact. If the license is unused (open-source distribution), the field should be removed or set to an empty string. If it is needed for licensing, it should be read from stored options.

---

### SUGGESTION-03 — `handleChargeCompleted` uses `sendResponse` as a return-substitute, creating dead code {#suggestion-03}

**File:** `includes/Webhook/FlutterwaveWebhook.php`
**Lines:** 196–262 (`handleChargeCompleted()`)

**Description:**

`$this->sendResponse()` calls `exit` internally, which terminates execution. The function uses it as if it were `return`, but this pattern means any code accidentally placed after a `sendResponse()` call is silently dead. This is a code-quality issue that makes the flow hard to reason about and error-prone during future edits.

For example, at line 254:

```php
if (!$transactionModel || $transactionModel->status != Status::TRANSACTION_SUCCEEDED) {
    $this->sendResponse(200, 'Transaction not found or not successful...');
}
// code here is dead if sendResponse was called, but visually appears to continue
```

The recommended pattern (as used in the Razorpay implementation) is to use explicit `return` statements for early exits within event handlers and call `sendResponse` only once at the very end.

---

### SUGGESTION-04 — Subscription plan ID cache key includes `$order->variation_id` which can be `null` {#suggestion-04}

**File:** `includes/Subscriptions/FlutterwaveSubscriptions.php`
**Lines:** 158–165 (`getOrCreateFlutterwavePlan()`)

**Description:**

The plan cache key is constructed as:

```php
$fctFlutterwavePlanId = 'fct_flutterwave_plan_'
    . $order->mode . '_'
    . $product->id . '_'
    . $order->variation_id . '_'   // can be null
    . $subscription->recurring_total . '_'
    . $subscription->billing_interval . '_'
    . $billTimes . '_'
    . $transaction->currency;
```

When `$order->variation_id` is `null` (for products without variations), PHP coerces it to an empty string, producing a key like `fct_flutterwave_plan_live_42__1000_monthly_12_USD`. Two different products both without variations could share the same plan ID cache key if all other fields happen to match, causing the wrong cached plan ID to be used.

**Recommended Fix:** Use `($order->variation_id ?? 'novariant')` to make null explicit and distinguishable.

---

## Summary Table

| #  | Finding                                                              | Severity   | File                                        |
|----|----------------------------------------------------------------------|------------|---------------------------------------------|
| 1  | Webhook accepted without secret when hash not configured             | HIGH       | `includes/Webhook/FlutterwaveWebhook.php`   |
| 2  | `subscription.cancelled` bypasses signature verification entirely    | HIGH       | `includes/Webhook/FlutterwaveWebhook.php`   |
| 3  | `isFlutterwaveBindingValid` returns true when all metadata absent    | HIGH       | `includes/Confirmations/FlutterwaveConfirmations.php` |
| 4  | `beforeSettingsUpdate` silently overwrites inactive mode's secret    | MEDIUM     | `includes/FlutterwaveGateway.php`           |
| 5  | Zero-decimal currencies produce 100× wrong amounts                   | MEDIUM     | `includes/FlutterwaveHelper.php`            |
| 6  | Refund UUID uses `md5(time() . uuid4)` — weaker than UUID4 alone    | MEDIUM     | `includes/Refund/FlutterwaveRefund.php`     |
| 7  | Updater uses `sslverify => false` for update API requests            | SUGGESTION | `includes/PluginManager/Updater.php`        |
| 8  | Hardcoded placeholder license `"12345"` sent to update API           | SUGGESTION | `flutterwave-for-fluent-cart.php`           |
| 9  | `sendResponse()` used as `return`; creates dead code patterns        | SUGGESTION | `includes/Webhook/FlutterwaveWebhook.php`   |
| 10 | Plan cache key includes nullable `variation_id` without null guard   | SUGGESTION | `includes/Subscriptions/FlutterwaveSubscriptions.php` |

---

## Priority Fix Order

1. **HIGH-02** (subscription.cancelled bypass) — Unconditional auth bypass with no secondary gate; fix is a one-line change with no functional risk.
2. **HIGH-01** (no secret → accept all webhooks) — Changes default behaviour from permissive to strict; requires merchants to set the secret before going live (document this).
3. **HIGH-03** (binding validation flaw) — Tighten `isFlutterwaveBindingValid` to require at least one verified anchor, not just a present-but-unvalidated `tx_ref`.
4. **MEDIUM-01** (secret key erasure on save) — Fix `beforeSettingsUpdate` to preserve inactive mode's key; low regression risk, high merchant-impact if triggered.
5. **MEDIUM-02** (zero-decimal currencies) — Add currency-aware amount conversion; only affects a subset of currencies but causes financial discrepancies when triggered.
6. **MEDIUM-03** (UUID generation) — Minor cleanup; use `wp_generate_uuid4()` directly.
7. **SUGGESTION-01** (sslverify false) — Enable SSL verification in updater.
8. **SUGGESTION-02** through **04** — Developer experience and code quality; no direct security impact.

---

## Considered & Dismissed

| Candidate                                                       | Reason Dismissed                                                                                                                                                                         |
|-----------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Webhook amount not re-verified against order total              | Flutterwave controls amounts server-side. A signed webhook with `status=successful` means the gateway confirmed the payment. Classified as defense-in-depth (HIGH-01 covers the real gap). |
| `wp_ajax_nopriv_` on confirmation endpoint                      | Guest checkout requires unauthenticated access. The endpoint uses nonce verification and server-side API re-verification. Not a vulnerability.                                            |
| Transaction ID from browser request (`transaction_id` param)   | Used only to call `FlutterwaveAPI::getFlutterwaveObject('transactions/{id}/verify')`. The response is fetched from Flutterwave's servers, not trusted as-is from the browser.            |
| Missing nonce on webhook IPN endpoint                           | Webhooks are server-to-server. Nonces are for browser sessions. Signature verification is the correct authentication mechanism for webhooks.                                              |
| Race condition between webhook and AJAX confirmation            | Both paths call `confirmPaymentSuccessByCharge` which checks `$transactionModel->status === Status::TRANSACTION_SUCCEEDED` before updating. Idempotency guard exists.                    |
| `sanitize_text_field` on HMAC signature header                  | `sanitize_text_field` strips HTML tags but preserves hex characters. Flutterwave HMAC signatures are hex strings, so sanitization does not corrupt the value.                            |
| Admin filter `flutterwave_fc/settings` on settings object       | This is a standard WordPress extensibility hook behind admin capability. Not a security concern; shop owner can always modify their own payment settings.                                 |
| `apply_filters` on `flutterwave-for-fluent-cart/supported_currencies` | Allows custom currencies; controllable only by code with admin/server access. Not an attack surface.                                                                             |
| `apply_filters` on `fluent_cart/flutterwave/onetime_payment_args` in FlutterwaveProcessor | Returns data to the browser for use in the inline checkout popup. The `public_key` is the publishable key (safe to expose). Other fields are order metadata the customer already knows. |
| Flutterwave CDN script loaded dynamically in JS                 | Loaded from `https://checkout.flutterwave.com/v3.js` (first-party Flutterwave CDN). Subresource Integrity would be ideal but this is consistent with all major gateway inline checkouts. |
